{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-14122", "model_patch": "diff --git a/debug_groupby.py b/debug_groupby.py\nnew file mode 100644\nindex 0000000000..f79002e92b\n--- /dev/null\n+++ b/debug_groupby.py\n@@ -0,0 +1,107 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the tests directory to the path so we can import the test models\n+sys.path.insert(0, '/testbed/tests')\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'aggregation_regress',  # Use the existing aggregation_regress test app\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import connection\n+from django.db.models import Count, Sum\n+from aggregation_regress.models import Author, Book, Publisher\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Publisher)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+publisher1 = Publisher.objects.create(name=\"Test Publisher\", num_awards=1)\n+book1 = Book.objects.create(\n+    isbn='123456789', name='Book A', pages=100, rating=4.0, \n+    price=10.00, contact=author1, publisher=publisher1, pubdate='2023-01-01'\n+)\n+book1.authors.add(author1)\n+\n+print(\"Test data created successfully!\")\n+\n+# Test the GROUP BY generation\n+print(\"\\n=== Debugging GROUP BY generation ===\")\n+\n+from django.db.models.sql.compiler import SQLCompiler\n+\n+# Test 1: Query with Meta.ordering\n+print(\"\\n=== Test 1: Query with Meta.ordering ===\")\n+qs1 = Book.objects.annotate(author_count=Count('authors')).values('isbn', 'author_count')\n+compiler1 = qs1.query.get_compiler('default')\n+compiler1.setup_query()\n+order_by1 = compiler1.get_order_by()\n+select1 = compiler1.select\n+\n+print(f\"Query 1:\")\n+print(f\"  _meta_ordering: {getattr(compiler1, '_meta_ordering', None)}\")\n+print(f\"  query.group_by: {qs1.query.group_by}\")\n+print(f\"  _fields: {qs1._fields}\")\n+print(f\"  select expressions: {len(select1)}\")\n+for i, (expr, alias, _) in enumerate(select1):\n+    print(f\"    {i}: {expr} (alias: {alias})\")\n+print(f\"  order_by expressions: {len(order_by1)}\")\n+for i, (expr, (sql, params, is_ref)) in enumerate(order_by1):\n+    print(f\"    {i}: {expr} -> {sql} (is_ref: {is_ref})\")\n+\n+# Now let's manually call get_group_by to see what happens\n+extra_select1, order_by1, group_by1 = compiler1.pre_sql_setup()\n+print(f\"  group_by expressions: {len(group_by1)}\")\n+for i, (sql, params) in enumerate(group_by1):\n+    print(f\"    {i}: {sql}\")\n+\n+# Test 2: Query without ordering\n+print(\"\\n=== Test 2: Query without ordering ===\")\n+qs2 = Book.objects.annotate(author_count=Count('authors')).order_by().values('isbn', 'author_count')\n+compiler2 = qs2.query.get_compiler('default')\n+compiler2.setup_query()\n+order_by2 = compiler2.get_order_by()\n+select2 = compiler2.select\n+\n+print(f\"Query 2:\")\n+print(f\"  _meta_ordering: {getattr(compiler2, '_meta_ordering', None)}\")\n+print(f\"  query.group_by: {qs2.query.group_by}\")\n+print(f\"  _fields: {qs2._fields}\")\n+print(f\"  select expressions: {len(select2)}\")\n+for i, (expr, alias, _) in enumerate(select2):\n+    print(f\"    {i}: {expr} (alias: {alias})\")\n+print(f\"  order_by expressions: {len(order_by2)}\")\n+for i, (expr, (sql, params, is_ref)) in enumerate(order_by2):\n+    print(f\"    {i}: {expr} -> {sql} (is_ref: {is_ref})\")\n+\n+# Now let's manually call get_group_by to see what happens\n+extra_select2, order_by2, group_by2 = compiler2.pre_sql_setup()\n+print(f\"  group_by expressions: {len(group_by2)}\")\n+for i, (sql, params) in enumerate(group_by2):\n+    print(f\"    {i}: {sql}\")\n\\ No newline at end of file\ndiff --git a/debug_ordering.py b/debug_ordering.py\nnew file mode 100644\nindex 0000000000..45d7fdc4e0\n--- /dev/null\n+++ b/debug_ordering.py\n@@ -0,0 +1,85 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the tests directory to the path so we can import the test models\n+sys.path.insert(0, '/testbed/tests')\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'aggregation_regress',  # Use the existing aggregation_regress test app\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import connection\n+from django.db.models import Count, Sum\n+from aggregation_regress.models import Author, Book, Publisher\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Publisher)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+publisher1 = Publisher.objects.create(name=\"Test Publisher\", num_awards=1)\n+book1 = Book.objects.create(\n+    isbn='123456789', name='Book A', pages=100, rating=4.0, \n+    price=10.00, contact=author1, publisher=publisher1, pubdate='2023-01-01'\n+)\n+book1.authors.add(author1)\n+\n+print(\"Test data created successfully!\")\n+\n+# Test 1: Query with Meta.ordering\n+print(\"\\n=== Test 1: Query with Meta.ordering ===\")\n+qs1 = Book.objects.annotate(author_count=Count('authors')).values('isbn', 'author_count')\n+print(f\"Query 1 order_by: {qs1.query.order_by}\")\n+print(f\"Query 1 default_ordering: {qs1.query.default_ordering}\")\n+\n+# Test 2: Query with explicit order_by()\n+print(\"\\n=== Test 2: Query with explicit order_by() ===\")\n+qs2 = Book.objects.annotate(author_count=Count('authors')).order_by().values('isbn', 'author_count')\n+print(f\"Query 2 order_by: {qs2.query.order_by}\")\n+print(f\"Query 2 default_ordering: {qs2.query.default_ordering}\")\n+\n+# Test 3: Query with explicit order_by('name')\n+print(\"\\n=== Test 3: Query with explicit order_by('name') ===\")\n+qs3 = Book.objects.annotate(author_count=Count('authors')).order_by('name').values('isbn', 'author_count')\n+print(f\"Query 3 order_by: {qs3.query.order_by}\")\n+print(f\"Query 3 default_ordering: {qs3.query.default_ordering}\")\n+\n+# Now let's see what happens in the compiler\n+print(\"\\n=== Compiler analysis ===\")\n+\n+from django.db.models.sql.compiler import SQLCompiler\n+\n+for i, qs in enumerate([qs1, qs2, qs3], 1):\n+    print(f\"\\nQuery {i}:\")\n+    compiler = qs.query.get_compiler('default')\n+    compiler.setup_query()\n+    order_by = compiler.get_order_by()\n+    print(f\"  _meta_ordering: {getattr(compiler, '_meta_ordering', None)}\")\n+    print(f\"  order_by expressions: {len(order_by)}\")\n+    for j, (expr, (sql, params, is_ref)) in enumerate(order_by):\n+        print(f\"    {j}: {expr} -> {sql} (is_ref: {is_ref})\")\n\\ No newline at end of file\ndiff --git a/debug_set_group_by.py b/debug_set_group_by.py\nnew file mode 100644\nindex 0000000000..c3456c557f\n--- /dev/null\n+++ b/debug_set_group_by.py\n@@ -0,0 +1,96 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the tests directory to the path so we can import the test models\n+sys.path.insert(0, '/testbed/tests')\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'aggregation_regress',  # Use the existing aggregation_regress test app\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import connection\n+from django.db.models import Count, Sum\n+from aggregation_regress.models import Author, Book, Publisher\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Publisher)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+publisher1 = Publisher.objects.create(name=\"Test Publisher\", num_awards=1)\n+book1 = Book.objects.create(\n+    isbn='123456789', name='Book A', pages=100, rating=4.0, \n+    price=10.00, contact=author1, publisher=publisher1, pubdate='2023-01-01'\n+)\n+book1.authors.add(author1)\n+\n+print(\"Test data created successfully!\")\n+\n+# Test the set_group_by method\n+print(\"\\n=== Debugging set_group_by method ===\")\n+\n+# Create a query with aggregation\n+qs = Book.objects.annotate(author_count=Count('authors')).values('isbn', 'author_count')\n+\n+print(f\"Before set_group_by:\")\n+print(f\"  query.select: {qs.query.select}\")\n+print(f\"  query.annotation_select: {qs.query.annotation_select}\")\n+print(f\"  query.group_by: {qs.query.group_by}\")\n+\n+# Manually call set_group_by to see what happens\n+print(f\"\\nCalling set_group_by...\")\n+\n+# Let's monkey patch set_group_by to add debug prints\n+original_set_group_by = qs.query.set_group_by\n+\n+def debug_set_group_by(allow_aliases=True):\n+    print(f\"  set_group_by called with allow_aliases={allow_aliases}\")\n+    print(f\"  self.select: {qs.query.select}\")\n+    print(f\"  self.annotation_select: {qs.query.annotation_select}\")\n+    \n+    group_by = list(qs.query.select)\n+    print(f\"  initial group_by from self.select: {group_by}\")\n+    \n+    if qs.query.annotation_select:\n+        for alias, annotation in qs.query.annotation_select.items():\n+            print(f\"  processing annotation {alias}: {annotation}\")\n+            group_by_cols = annotation.get_group_by_cols(alias=alias)\n+            print(f\"    annotation.get_group_by_cols() returned: {group_by_cols}\")\n+            group_by.extend(group_by_cols)\n+            print(f\"    group_by after extending: {group_by}\")\n+    \n+    qs.query.group_by = tuple(group_by)\n+    print(f\"  final group_by: {qs.query.group_by}\")\n+\n+qs.query.set_group_by = debug_set_group_by\n+\n+# Now call set_group_by\n+qs.query.set_group_by()\n+\n+print(f\"\\nAfter set_group_by:\")\n+print(f\"  query.group_by: {qs.query.group_by}\")\n\\ No newline at end of file\ndiff --git a/debug_test6.py b/debug_test6.py\nnew file mode 100644\nindex 0000000000..6580cb6e16\n--- /dev/null\n+++ b/debug_test6.py\n@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the tests directory to the path so we can import the test models\n+sys.path.insert(0, '/testbed/tests')\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'aggregation_regress',  # Use the existing aggregation_regress test app\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import connection\n+from django.db.models import Count, Avg\n+from aggregation_regress.models import Author, Book, Publisher\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Publisher)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+publisher1 = Publisher.objects.create(name=\"Test Publisher\", num_awards=1)\n+book1 = Book.objects.create(\n+    isbn='123456789', name='Book A', pages=100, rating=4.0, \n+    price=10.00, contact=author1, publisher=publisher1, pubdate='2023-01-01'\n+)\n+book1.authors.add(author1)\n+\n+print(\"Test data created successfully!\")\n+\n+# Debug Test 6\n+print(\"\\n=== Debugging Test 6 ===\")\n+qs = Book.objects.annotate(\n+    author_count=Count('authors'),\n+    avg_rating=Avg('rating')\n+).values('publisher__name', 'author_count', 'avg_rating')\n+\n+compiler = qs.query.get_compiler('default')\n+extra_select, order_by, group_by = compiler.pre_sql_setup()\n+select = compiler.select\n+\n+print(f\"SELECT expressions:\")\n+for i, (expr, alias, _) in enumerate(select):\n+    print(f\"  {i}: {expr} (alias: {alias})\")\n+    if hasattr(expr, 'target') and hasattr(expr.target, 'column'):\n+        print(f\"      target.column: {expr.target.column}\")\n+\n+print(f\"\\nMeta.ordering: {qs.query.model._meta.ordering}\")\n+print(f\"_meta_ordering: {getattr(compiler, '_meta_ordering', None)}\")\n+print(f\"query.extra_order_by: {qs.query.extra_order_by}\")\n+print(f\"query.default_ordering: {qs.query.default_ordering}\")\n+print(f\"query.order_by: {qs.query.order_by}\")\n+\n+print(f\"order_by expressions: {len(order_by)}\")\n+for i, (expr, (sql, params, is_ref)) in enumerate(order_by):\n+    print(f\"  {i}: {expr} -> {sql} (is_ref: {is_ref})\")\n+print(f\"_meta_ordering after pre_sql_setup: {getattr(compiler, '_meta_ordering', None)}\")\n+\n+print(f\"group_by expressions: {len(group_by)}\")\n+for i, (sql, params) in enumerate(group_by):\n+    print(f\"  {i}: {sql}\")\n+\n+# Execute the query to see the SQL\n+connection.queries_log.clear()\n+result = list(qs)\n+if connection.queries:\n+    sql = connection.queries[-1]['sql']\n+    print(f\"\\nSQL: {sql}\")\n+    \n+    # Check if 'name' is in GROUP BY\n+    if 'GROUP BY' in sql and '\"aggregation_regress_book\".\"name\"' in sql:\n+        print(\"\u274c ISSUE: Meta.ordering field 'name' is in GROUP BY clause\")\n+    else:\n+        print(\"\u2705 GOOD: Meta.ordering field 'name' is NOT in GROUP BY clause\")\n\\ No newline at end of file\ndiff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py\nindex 850734709d..5fa3fe9759 100644\n--- a/django/db/models/sql/compiler.py\n+++ b/django/db/models/sql/compiler.py\n@@ -133,6 +133,50 @@ class SQLCompiler:\n         having_group_by = self.having.get_group_by_cols() if self.having else ()\n         for expr in having_group_by:\n             expressions.append(expr)\n+        # Check if we have aggregations in the query\n+        has_aggregations = any(\n+            getattr(annotation, 'contains_aggregate', False)\n+            for annotation in self.query.annotation_select.values()\n+        )\n+        \n+        # If we have aggregations and Meta.ordering was used, we should exclude\n+        # Meta.ordering fields from the GROUP BY clause to avoid incorrect aggregation results,\n+        # but only if they are not explicitly included in the SELECT clause\n+        if has_aggregations and self._meta_ordering:\n+            # Get the Meta.ordering field names\n+            meta_ordering_fields = set()\n+            for field_name in self._meta_ordering:\n+                # Handle field names like '-name' or 'name'\n+                if field_name.startswith('-'):\n+                    field_name = field_name[1:]\n+                # Convert field name to column reference\n+                try:\n+                    field = self.query.model._meta.get_field(field_name)\n+                    if hasattr(field, 'column'):\n+                        meta_ordering_fields.add(field.column)\n+                except:\n+                    # If we can't resolve the field, skip it\n+                    pass\n+            \n+            # Get the fields that are explicitly in the SELECT clause\n+            select_fields = set()\n+            for expr, _, _ in select:\n+                if hasattr(expr, 'target') and hasattr(expr.target, 'column'):\n+                    select_fields.add(expr.target.column)\n+            \n+            # Filter out expressions that correspond to Meta.ordering fields,\n+            # but only if they are not explicitly in the SELECT clause\n+            filtered_expressions = []\n+            for expr in expressions:\n+                # Check if this expression corresponds to a Meta.ordering field\n+                if hasattr(expr, 'target') and hasattr(expr.target, 'column'):\n+                    if (expr.target.column in meta_ordering_fields and \n+                        expr.target.column not in select_fields):\n+                        # Skip this expression as it's a Meta.ordering field not in SELECT\n+                        continue\n+                filtered_expressions.append(expr)\n+            expressions = filtered_expressions\n+\n         result = []\n         seen = set()\n         expressions = self.collapse_group_by(expressions, having_group_by)\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..dbb027d162\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,108 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Count\n+\n+# Define test models\n+class Author(models.Model):\n+    name = models.CharField(max_length=100)\n+    age = models.IntegerField()\n+    \n+    class Meta:\n+        ordering = ['name']  # This is the problematic Meta.ordering\n+        app_label = 'test'\n+\n+class Book(models.Model):\n+    title = models.CharField(max_length=200)\n+    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name='books')\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create tables\n+from django.core.management import execute_from_command_line\n+from django.db import connection\n+\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+author2 = Author.objects.create(name=\"Jane Smith\", age=25)\n+\n+Book.objects.create(title=\"Book 1\", author=author1)\n+Book.objects.create(title=\"Book 2\", author=author1)\n+Book.objects.create(title=\"Book 3\", author=author2)\n+\n+print(\"Test data created successfully!\")\n+\n+# Now test the aggregation issue\n+print(\"\\n=== Testing aggregation with Meta.ordering ===\")\n+\n+# This should return 2 authors, but due to the bug it might return wrong results\n+# because Meta.ordering fields are included in GROUP BY\n+from django.db import connection\n+from django.test.utils import override_settings\n+\n+# Enable query logging to see the generated SQL\n+connection.queries_log.clear()\n+\n+# Test the problematic query\n+print(\"Running aggregation query...\")\n+result = Author.objects.annotate(book_count=Count('books')).values('name', 'book_count')\n+\n+print(\"Results:\")\n+for item in result:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(list(result))}\")\n+\n+# Print the SQL query to see if Meta.ordering fields are in GROUP BY\n+if connection.queries:\n+    print(f\"\\nGenerated SQL:\")\n+    for query in connection.queries:\n+        print(f\"  {query['sql']}\")\n+\n+# Test without ordering to compare\n+print(\"\\n=== Testing same query without ordering ===\")\n+connection.queries_log.clear()\n+\n+result_no_order = Author.objects.annotate(book_count=Count('books')).order_by().values('name', 'book_count')\n+\n+print(\"Results without ordering:\")\n+for item in result_no_order:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(list(result_no_order))}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL without ordering:\")\n+    for query in connection.queries:\n+        print(f\"  {query['sql']}\")\n\\ No newline at end of file\ndiff --git a/reproduce_issue_simple.py b/reproduce_issue_simple.py\nnew file mode 100644\nindex 0000000000..629a84248c\n--- /dev/null\n+++ b/reproduce_issue_simple.py\n@@ -0,0 +1,151 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the tests directory to the path so we can import the test models\n+sys.path.insert(0, '/testbed/tests')\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'aggregation',  # Use the existing aggregation test app\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import connection\n+from django.db.models import Count\n+from aggregation.models import Author, Book\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+author2 = Author.objects.create(name=\"Jane Smith\", age=25)\n+\n+book1 = Book.objects.create(\n+    isbn='123456789', name='Book 1', pages=100, rating=4.0, \n+    price=10.00, contact=author1, publisher_id=1, pubdate='2023-01-01'\n+)\n+book2 = Book.objects.create(\n+    isbn='987654321', name='Book 2', pages=200, rating=4.5, \n+    price=15.00, contact=author1, publisher_id=1, pubdate='2023-01-02'\n+)\n+book3 = Book.objects.create(\n+    isbn='555666777', name='Book 3', pages=150, rating=3.5, \n+    price=12.00, contact=author2, publisher_id=1, pubdate='2023-01-03'\n+)\n+\n+print(\"Test data created successfully!\")\n+\n+# Now let's create a model with Meta.ordering to test the issue\n+from django.db import models\n+\n+class OrderedAuthor(models.Model):\n+    name = models.CharField(max_length=100)\n+    age = models.IntegerField()\n+    \n+    class Meta:\n+        ordering = ['name']  # This is the problematic Meta.ordering\n+        app_label = 'test'\n+\n+class OrderedBook(models.Model):\n+    title = models.CharField(max_length=200)\n+    author = models.ForeignKey(OrderedAuthor, on_delete=models.CASCADE, related_name='books')\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create tables for ordered models\n+print(\"Creating ordered models tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(OrderedAuthor)\n+    schema_editor.create_model(OrderedBook)\n+\n+# Insert test data for ordered models\n+print(\"Inserting test data for ordered models...\")\n+ordered_author1 = OrderedAuthor.objects.create(name=\"John Doe\", age=30)\n+ordered_author2 = OrderedAuthor.objects.create(name=\"Jane Smith\", age=25)\n+\n+OrderedBook.objects.create(title=\"Book 1\", author=ordered_author1)\n+OrderedBook.objects.create(title=\"Book 2\", author=ordered_author1)\n+OrderedBook.objects.create(title=\"Book 3\", author=ordered_author2)\n+\n+print(\"Test data for ordered models created successfully!\")\n+\n+# Now test the aggregation issue\n+print(\"\\n=== Testing aggregation with Meta.ordering ===\")\n+\n+# Enable query logging to see the generated SQL\n+connection.queries_log.clear()\n+\n+# Test the problematic query\n+print(\"Running aggregation query with Meta.ordering...\")\n+result = list(OrderedAuthor.objects.annotate(book_count=Count('books')).values('name', 'book_count'))\n+\n+print(\"Results:\")\n+for item in result:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(result)}\")\n+\n+# Print the SQL query to see if Meta.ordering fields are in GROUP BY\n+if connection.queries:\n+    print(f\"\\nGenerated SQL:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        # Check if the ordering field 'name' is in the GROUP BY clause\n+        if 'GROUP BY' in sql and 'name' in sql:\n+            print(\"  *** ISSUE: Meta.ordering field 'name' is included in GROUP BY clause! ***\")\n+\n+# Test without ordering to compare\n+print(\"\\n=== Testing same query without ordering ===\")\n+connection.queries_log.clear()\n+\n+result_no_order = list(OrderedAuthor.objects.annotate(book_count=Count('books')).order_by().values('name', 'book_count'))\n+\n+print(\"Results without ordering:\")\n+for item in result_no_order:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(result_no_order)}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL without ordering:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        # Check if the ordering field 'name' is in the GROUP BY clause\n+        if 'GROUP BY' in sql and 'name' in sql:\n+            print(\"  *** ISSUE: Meta.ordering field 'name' is still included in GROUP BY clause! ***\")\n+        else:\n+            print(\"  *** GOOD: Meta.ordering field 'name' is NOT in GROUP BY clause ***\")\n+\n+print(\"\\n=== Summary ===\")\n+print(f\"With Meta.ordering: {len(result)} results\")\n+print(f\"Without ordering: {len(result_no_order)} results\")\n+if len(result) == len(result_no_order):\n+    print(\"Results are the same - no issue detected in this simple case\")\n+else:\n+    print(\"Results are different - this demonstrates the issue!\")\n\\ No newline at end of file\ndiff --git a/test_comprehensive_fix.py b/test_comprehensive_fix.py\nnew file mode 100644\nindex 0000000000..9705da48fe\n--- /dev/null\n+++ b/test_comprehensive_fix.py\n@@ -0,0 +1,155 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the tests directory to the path so we can import the test models\n+sys.path.insert(0, '/testbed/tests')\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'aggregation_regress',  # Use the existing aggregation_regress test app\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import connection\n+from django.db.models import Count, Sum, Avg\n+from aggregation_regress.models import Author, Book, Publisher\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Publisher)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+author2 = Author.objects.create(name=\"Jane Smith\", age=25)\n+\n+publisher1 = Publisher.objects.create(name=\"Test Publisher\", num_awards=1)\n+\n+book1 = Book.objects.create(\n+    isbn='123456789', name='Book A', pages=100, rating=4.0, \n+    price=10.00, contact=author1, publisher=publisher1, pubdate='2023-01-01'\n+)\n+book2 = Book.objects.create(\n+    isbn='987654321', name='Book B', pages=200, rating=4.5, \n+    price=15.00, contact=author1, publisher=publisher1, pubdate='2023-01-02'\n+)\n+book3 = Book.objects.create(\n+    isbn='555666777', name='Book C', pages=150, rating=3.5, \n+    price=12.00, contact=author2, publisher=publisher1, pubdate='2023-01-03'\n+)\n+\n+# Add authors to books\n+book1.authors.add(author1)\n+book2.authors.add(author1)\n+book3.authors.add(author2)\n+\n+print(\"Test data created successfully!\")\n+\n+def check_sql_for_meta_ordering_in_group_by(sql, should_contain=False):\n+    \"\"\"Check if the SQL contains Meta.ordering field 'name' in GROUP BY clause\"\"\"\n+    has_name_in_group_by = 'GROUP BY' in sql and '\"aggregation_regress_book\".\"name\"' in sql\n+    if should_contain:\n+        if has_name_in_group_by:\n+            print(\"  \u2705 GOOD: Meta.ordering field 'name' is correctly included in GROUP BY clause\")\n+        else:\n+            print(\"  \u274c ISSUE: Meta.ordering field 'name' should be included in GROUP BY clause but is not\")\n+    else:\n+        if has_name_in_group_by:\n+            print(\"  \u274c ISSUE: Meta.ordering field 'name' is incorrectly included in GROUP BY clause\")\n+        else:\n+            print(\"  \u2705 GOOD: Meta.ordering field 'name' is correctly excluded from GROUP BY clause\")\n+\n+# Test 1: Aggregation with Meta.ordering (should exclude Meta.ordering from GROUP BY)\n+print(\"\\n=== Test 1: Aggregation with Meta.ordering ===\")\n+connection.queries_log.clear()\n+result1 = list(Book.objects.annotate(author_count=Count('authors')).values('isbn', 'author_count'))\n+print(f\"Results: {len(result1)} books\")\n+if connection.queries:\n+    sql = connection.queries[-1]['sql']\n+    print(f\"SQL: {sql}\")\n+    check_sql_for_meta_ordering_in_group_by(sql, should_contain=False)\n+\n+# Test 2: Aggregation without ordering (should include all fields in GROUP BY)\n+print(\"\\n=== Test 2: Aggregation without ordering ===\")\n+connection.queries_log.clear()\n+result2 = list(Book.objects.annotate(author_count=Count('authors')).order_by().values('isbn', 'author_count'))\n+print(f\"Results: {len(result2)} books\")\n+if connection.queries:\n+    sql = connection.queries[-1]['sql']\n+    print(f\"SQL: {sql}\")\n+    check_sql_for_meta_ordering_in_group_by(sql, should_contain=True)\n+\n+# Test 3: Aggregation with explicit ordering (should include explicit ordering in GROUP BY)\n+print(\"\\n=== Test 3: Aggregation with explicit ordering ===\")\n+connection.queries_log.clear()\n+result3 = list(Book.objects.annotate(author_count=Count('authors')).order_by('name').values('isbn', 'author_count'))\n+print(f\"Results: {len(result3)} books\")\n+if connection.queries:\n+    sql = connection.queries[-1]['sql']\n+    print(f\"SQL: {sql}\")\n+    # With explicit ordering, the 'name' field should be in GROUP BY because it's explicitly requested\n+    check_sql_for_meta_ordering_in_group_by(sql, should_contain=True)\n+\n+# Test 4: Non-aggregation query with Meta.ordering (should work normally)\n+print(\"\\n=== Test 4: Non-aggregation query with Meta.ordering ===\")\n+connection.queries_log.clear()\n+result4 = list(Book.objects.values('isbn', 'name'))\n+print(f\"Results: {len(result4)} books\")\n+if connection.queries:\n+    sql = connection.queries[-1]['sql']\n+    print(f\"SQL: {sql}\")\n+    # Non-aggregation queries should not have GROUP BY at all\n+    if 'GROUP BY' in sql:\n+        print(\"  \u274c ISSUE: Non-aggregation query should not have GROUP BY clause\")\n+    else:\n+        print(\"  \u2705 GOOD: Non-aggregation query correctly has no GROUP BY clause\")\n+\n+# Test 5: Aggregation with values that include Meta.ordering field\n+print(\"\\n=== Test 5: Aggregation with values that include Meta.ordering field ===\")\n+connection.queries_log.clear()\n+result5 = list(Book.objects.annotate(author_count=Count('authors')).values('name', 'author_count'))\n+print(f\"Results: {len(result5)} books\")\n+if connection.queries:\n+    sql = connection.queries[-1]['sql']\n+    print(f\"SQL: {sql}\")\n+    # When 'name' is explicitly requested in values(), it should be in GROUP BY\n+    check_sql_for_meta_ordering_in_group_by(sql, should_contain=True)\n+\n+# Test 6: Complex aggregation with multiple fields\n+print(\"\\n=== Test 6: Complex aggregation with multiple fields ===\")\n+connection.queries_log.clear()\n+result6 = list(Book.objects.annotate(\n+    author_count=Count('authors'),\n+    avg_rating=Avg('rating')\n+).values('publisher__name', 'author_count', 'avg_rating'))\n+print(f\"Results: {len(result6)} publishers\")\n+if connection.queries:\n+    sql = connection.queries[-1]['sql']\n+    print(f\"SQL: {sql}\")\n+    # Meta.ordering field 'name' should not be in GROUP BY for this query\n+    check_sql_for_meta_ordering_in_group_by(sql, should_contain=False)\n+\n+print(\"\\n=== Summary ===\")\n+print(\"All tests completed. The fix correctly excludes Meta.ordering fields from GROUP BY\")\n+print(\"when we have aggregations, but preserves them when they are explicitly requested.\")\n\\ No newline at end of file\ndiff --git a/test_meta_ordering_groupby.py b/test_meta_ordering_groupby.py\nnew file mode 100644\nindex 0000000000..b4ef5062d5\n--- /dev/null\n+++ b/test_meta_ordering_groupby.py\n@@ -0,0 +1,185 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the tests directory to the path so we can import the test models\n+sys.path.insert(0, '/testbed/tests')\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'aggregation_regress',  # Use the existing aggregation_regress test app\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import connection\n+from django.db.models import Count, Sum\n+from aggregation_regress.models import Author, Book, Publisher\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Publisher)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+author2 = Author.objects.create(name=\"Jane Smith\", age=25)\n+\n+publisher1 = Publisher.objects.create(name=\"Test Publisher\", num_awards=1)\n+\n+book1 = Book.objects.create(\n+    isbn='123456789', name='Book A', pages=100, rating=4.0, \n+    price=10.00, contact=author1, publisher=publisher1, pubdate='2023-01-01'\n+)\n+book2 = Book.objects.create(\n+    isbn='987654321', name='Book B', pages=200, rating=4.5, \n+    price=15.00, contact=author1, publisher=publisher1, pubdate='2023-01-02'\n+)\n+book3 = Book.objects.create(\n+    isbn='555666777', name='Book C', pages=150, rating=3.5, \n+    price=12.00, contact=author2, publisher=publisher1, pubdate='2023-01-03'\n+)\n+\n+# Add authors to books\n+book1.authors.add(author1)\n+book2.authors.add(author1)\n+book3.authors.add(author2)\n+\n+print(\"Test data created successfully!\")\n+\n+# Now test the aggregation issue\n+print(\"\\n=== Testing aggregation with Meta.ordering ===\")\n+print(\"Book model has Meta.ordering = ('name',)\")\n+\n+# Enable query logging to see the generated SQL\n+connection.queries_log.clear()\n+\n+# Test the problematic query - this should NOT include 'name' in GROUP BY\n+print(\"Running aggregation query with Meta.ordering...\")\n+result = list(Book.objects.annotate(author_count=Count('authors')).values('name', 'author_count'))\n+\n+print(\"Results:\")\n+for item in result:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(result)}\")\n+\n+# Print the SQL query to see if Meta.ordering fields are in GROUP BY\n+if connection.queries:\n+    print(f\"\\nGenerated SQL:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        # Check if the ordering field 'name' is in the GROUP BY clause\n+        if 'GROUP BY' in sql:\n+            if '\"aggregation_regress_book\".\"name\"' in sql:\n+                print(\"  *** ISSUE: Meta.ordering field 'name' is included in GROUP BY clause! ***\")\n+            else:\n+                print(\"  *** GOOD: Meta.ordering field 'name' is NOT in GROUP BY clause ***\")\n+\n+# Test without ordering to compare\n+print(\"\\n=== Testing same query without ordering ===\")\n+connection.queries_log.clear()\n+\n+result_no_order = list(Book.objects.annotate(author_count=Count('authors')).order_by().values('name', 'author_count'))\n+\n+print(\"Results without ordering:\")\n+for item in result_no_order:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(result_no_order)}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL without ordering:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        # Check if the ordering field 'name' is in the GROUP BY clause\n+        if 'GROUP BY' in sql:\n+            if '\"aggregation_regress_book\".\"name\"' in sql:\n+                print(\"  *** ISSUE: Meta.ordering field 'name' is still included in GROUP BY clause! ***\")\n+            else:\n+                print(\"  *** GOOD: Meta.ordering field 'name' is NOT in GROUP BY clause ***\")\n+\n+print(\"\\n=== Summary ===\")\n+print(f\"With Meta.ordering: {len(result)} results\")\n+print(f\"Without ordering: {len(result_no_order)} results\")\n+if len(result) == len(result_no_order):\n+    print(\"Results are the same - no issue detected in this simple case\")\n+else:\n+    print(\"Results are different - this demonstrates the issue!\")\n+\n+# Test a case that would show the issue more clearly\n+print(\"\\n=== Testing with duplicate names to show the issue ===\")\n+\n+# Add a book with the same name to show the issue\n+book4 = Book.objects.create(\n+    isbn='111222333', name='Book A', pages=300, rating=5.0,  # Same name as book1\n+    price=20.00, contact=author2, publisher=publisher1, pubdate='2023-01-04'\n+)\n+book4.authors.add(author2)\n+\n+connection.queries_log.clear()\n+result_with_duplicates = list(Book.objects.annotate(author_count=Count('authors')).values('name', 'author_count'))\n+\n+print(\"Results with duplicate names (with Meta.ordering):\")\n+for item in result_with_duplicates:\n+    print(f\"  {item}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL with duplicate names:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        if 'GROUP BY' in sql and '\"aggregation_regress_book\".\"name\"' in sql:\n+            print(\"  *** ISSUE: Meta.ordering field 'name' is included in GROUP BY clause! ***\")\n+            print(\"  *** This causes incorrect aggregation when there are multiple records with same name! ***\")\n+\n+connection.queries_log.clear()\n+result_no_order_duplicates = list(Book.objects.annotate(author_count=Count('authors')).order_by().values('name', 'author_count'))\n+\n+print(\"\\nResults with duplicate names (without ordering):\")\n+for item in result_no_order_duplicates:\n+    print(f\"  {item}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL with duplicate names (no ordering):\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+\n+print(f\"\\nWith Meta.ordering and duplicates: {len(result_with_duplicates)} results\")\n+print(f\"Without ordering and duplicates: {len(result_no_order_duplicates)} results\")\n+if len(result_with_duplicates) != len(result_no_order_duplicates):\n+    print(\"*** ISSUE CONFIRMED: Different number of results due to Meta.ordering in GROUP BY! ***\")\n+else:\n+    print(\"Results are the same - checking if aggregation values are different...\")\n+    # Check if the aggregation values are different\n+    with_ordering_dict = {item['name']: item['author_count'] for item in result_with_duplicates}\n+    without_ordering_dict = {item['name']: item['author_count'] for item in result_no_order_duplicates}\n+    \n+    if with_ordering_dict != without_ordering_dict:\n+        print(\"*** ISSUE CONFIRMED: Aggregation values are different due to Meta.ordering in GROUP BY! ***\")\n+        print(f\"With ordering: {with_ordering_dict}\")\n+        print(f\"Without ordering: {without_ordering_dict}\")\n+    else:\n+        print(\"Aggregation values are the same\")\n\\ No newline at end of file\ndiff --git a/test_meta_ordering_groupby_issue.py b/test_meta_ordering_groupby_issue.py\nnew file mode 100644\nindex 0000000000..cf5843491b\n--- /dev/null\n+++ b/test_meta_ordering_groupby_issue.py\n@@ -0,0 +1,174 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Add the tests directory to the path so we can import the test models\n+sys.path.insert(0, '/testbed/tests')\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            'aggregation_regress',  # Use the existing aggregation_regress test app\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import connection\n+from django.db.models import Count, Sum\n+from aggregation_regress.models import Author, Book, Publisher\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(Author)\n+    schema_editor.create_model(Publisher)\n+    schema_editor.create_model(Book)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = Author.objects.create(name=\"John Doe\", age=30)\n+author2 = Author.objects.create(name=\"Jane Smith\", age=25)\n+\n+publisher1 = Publisher.objects.create(name=\"Test Publisher\", num_awards=1)\n+\n+book1 = Book.objects.create(\n+    isbn='123456789', name='Book A', pages=100, rating=4.0, \n+    price=10.00, contact=author1, publisher=publisher1, pubdate='2023-01-01'\n+)\n+book2 = Book.objects.create(\n+    isbn='987654321', name='Book B', pages=200, rating=4.5, \n+    price=15.00, contact=author1, publisher=publisher1, pubdate='2023-01-02'\n+)\n+book3 = Book.objects.create(\n+    isbn='555666777', name='Book C', pages=150, rating=3.5, \n+    price=12.00, contact=author2, publisher=publisher1, pubdate='2023-01-03'\n+)\n+\n+# Add authors to books\n+book1.authors.add(author1)\n+book2.authors.add(author1)\n+book3.authors.add(author2)\n+\n+print(\"Test data created successfully!\")\n+\n+# Now test the specific issue: Meta.ordering fields in GROUP BY without being in SELECT\n+print(\"\\n=== Testing the specific issue: Meta.ordering fields in GROUP BY ===\")\n+print(\"Book model has Meta.ordering = ('name',)\")\n+\n+# Enable query logging to see the generated SQL\n+connection.queries_log.clear()\n+\n+# Test the problematic query - this should NOT include 'name' in GROUP BY\n+# because 'name' is not in the SELECT clause, only in Meta.ordering\n+print(\"Running aggregation query that doesn't select 'name' field...\")\n+result = list(Book.objects.annotate(author_count=Count('authors')).values('isbn', 'author_count'))\n+\n+print(\"Results:\")\n+for item in result:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(result)}\")\n+\n+# Print the SQL query to see if Meta.ordering fields are in GROUP BY\n+if connection.queries:\n+    print(f\"\\nGenerated SQL:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        # Check if the ordering field 'name' is in the GROUP BY clause\n+        # even though it's not in the SELECT clause\n+        if 'GROUP BY' in sql:\n+            if '\"aggregation_regress_book\".\"name\"' in sql:\n+                print(\"  *** ISSUE: Meta.ordering field 'name' is included in GROUP BY clause even though it's not in SELECT! ***\")\n+            else:\n+                print(\"  *** GOOD: Meta.ordering field 'name' is NOT in GROUP BY clause ***\")\n+\n+# Test without ordering to compare\n+print(\"\\n=== Testing same query without ordering ===\")\n+connection.queries_log.clear()\n+\n+result_no_order = list(Book.objects.annotate(author_count=Count('authors')).order_by().values('isbn', 'author_count'))\n+\n+print(\"Results without ordering:\")\n+for item in result_no_order:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(result_no_order)}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL without ordering:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        # Check if the ordering field 'name' is in the GROUP BY clause\n+        if 'GROUP BY' in sql:\n+            if '\"aggregation_regress_book\".\"name\"' in sql:\n+                print(\"  *** ISSUE: Meta.ordering field 'name' is still included in GROUP BY clause! ***\")\n+            else:\n+                print(\"  *** GOOD: Meta.ordering field 'name' is NOT in GROUP BY clause ***\")\n+\n+print(\"\\n=== Summary ===\")\n+print(f\"With Meta.ordering: {len(result)} results\")\n+print(f\"Without ordering: {len(result_no_order)} results\")\n+if len(result) == len(result_no_order):\n+    print(\"Results are the same - no issue detected in this simple case\")\n+else:\n+    print(\"Results are different - this demonstrates the issue!\")\n+\n+# Test a more complex aggregation that would show the issue\n+print(\"\\n=== Testing aggregation by publisher ===\")\n+\n+connection.queries_log.clear()\n+result_publisher = list(Book.objects.values('publisher__name').annotate(total_pages=Sum('pages')))\n+\n+print(\"Results aggregated by publisher (with Meta.ordering):\")\n+for item in result_publisher:\n+    print(f\"  {item}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL for publisher aggregation:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        if 'GROUP BY' in sql and '\"aggregation_regress_book\".\"name\"' in sql:\n+            print(\"  *** ISSUE: Meta.ordering field 'name' is included in GROUP BY clause! ***\")\n+            print(\"  *** This can cause incorrect aggregation results! ***\")\n+\n+connection.queries_log.clear()\n+result_publisher_no_order = list(Book.objects.values('publisher__name').annotate(total_pages=Sum('pages')).order_by())\n+\n+print(\"\\nResults aggregated by publisher (without ordering):\")\n+for item in result_publisher_no_order:\n+    print(f\"  {item}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL for publisher aggregation (no ordering):\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        if 'GROUP BY' in sql and '\"aggregation_regress_book\".\"name\"' in sql:\n+            print(\"  *** ISSUE: Meta.ordering field 'name' is still included in GROUP BY clause! ***\")\n+        else:\n+            print(\"  *** GOOD: Meta.ordering field 'name' is NOT in GROUP BY clause ***\")\n+\n+print(f\"\\nPublisher aggregation with Meta.ordering: {result_publisher}\")\n+print(f\"Publisher aggregation without ordering: {result_publisher_no_order}\")\n+if result_publisher != result_publisher_no_order:\n+    print(\"*** ISSUE CONFIRMED: Different aggregation results due to Meta.ordering in GROUP BY! ***\")\n+else:\n+    print(\"Aggregation results are the same\")\n\\ No newline at end of file\ndiff --git a/test_ordering_groupby.py b/test_ordering_groupby.py\nnew file mode 100644\nindex 0000000000..d0a3d5fa24\n--- /dev/null\n+++ b/test_ordering_groupby.py\n@@ -0,0 +1,159 @@\n+#!/usr/bin/env python\n+\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+        ],\n+        USE_TZ=True,\n+    )\n+\n+django.setup()\n+\n+from django.db import models, connection\n+from django.db.models import Count\n+\n+# Define test models with Meta.ordering\n+class OrderedAuthor(models.Model):\n+    name = models.CharField(max_length=100)\n+    age = models.IntegerField()\n+    \n+    class Meta:\n+        ordering = ['name']  # This is the problematic Meta.ordering\n+        app_label = 'test'\n+\n+class OrderedBook(models.Model):\n+    title = models.CharField(max_length=200)\n+    author = models.ForeignKey(OrderedAuthor, on_delete=models.CASCADE, related_name='books')\n+    \n+    class Meta:\n+        app_label = 'test'\n+\n+# Create tables\n+print(\"Creating tables...\")\n+with connection.schema_editor() as schema_editor:\n+    schema_editor.create_model(OrderedAuthor)\n+    schema_editor.create_model(OrderedBook)\n+\n+# Insert test data\n+print(\"Inserting test data...\")\n+author1 = OrderedAuthor.objects.create(name=\"John Doe\", age=30)\n+author2 = OrderedAuthor.objects.create(name=\"Jane Smith\", age=25)\n+\n+OrderedBook.objects.create(title=\"Book 1\", author=author1)\n+OrderedBook.objects.create(title=\"Book 2\", author=author1)\n+OrderedBook.objects.create(title=\"Book 3\", author=author2)\n+\n+print(\"Test data created successfully!\")\n+\n+# Now test the aggregation issue\n+print(\"\\n=== Testing aggregation with Meta.ordering ===\")\n+\n+# Enable query logging to see the generated SQL\n+connection.queries_log.clear()\n+\n+# Test the problematic query\n+print(\"Running aggregation query with Meta.ordering...\")\n+result = list(OrderedAuthor.objects.annotate(book_count=Count('books')).values('name', 'book_count'))\n+\n+print(\"Results:\")\n+for item in result:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(result)}\")\n+\n+# Print the SQL query to see if Meta.ordering fields are in GROUP BY\n+if connection.queries:\n+    print(f\"\\nGenerated SQL:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        # Check if the ordering field 'name' is in the GROUP BY clause\n+        if 'GROUP BY' in sql and '\"test_orderedauthor\".\"name\"' in sql:\n+            print(\"  *** ISSUE: Meta.ordering field 'name' is included in GROUP BY clause! ***\")\n+\n+# Test without ordering to compare\n+print(\"\\n=== Testing same query without ordering ===\")\n+connection.queries_log.clear()\n+\n+result_no_order = list(OrderedAuthor.objects.annotate(book_count=Count('books')).order_by().values('name', 'book_count'))\n+\n+print(\"Results without ordering:\")\n+for item in result_no_order:\n+    print(f\"  {item}\")\n+\n+print(f\"\\nNumber of results: {len(result_no_order)}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL without ordering:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        # Check if the ordering field 'name' is in the GROUP BY clause\n+        if 'GROUP BY' in sql and '\"test_orderedauthor\".\"name\"' in sql:\n+            print(\"  *** ISSUE: Meta.ordering field 'name' is still included in GROUP BY clause! ***\")\n+        else:\n+            print(\"  *** GOOD: Meta.ordering field 'name' is NOT in GROUP BY clause ***\")\n+\n+print(\"\\n=== Summary ===\")\n+print(f\"With Meta.ordering: {len(result)} results\")\n+print(f\"Without ordering: {len(result_no_order)} results\")\n+if len(result) == len(result_no_order):\n+    print(\"Results are the same - no issue detected in this simple case\")\n+else:\n+    print(\"Results are different - this demonstrates the issue!\")\n+\n+# Let's also test a more complex case that would show the issue more clearly\n+print(\"\\n=== Testing with more complex data that shows the issue ===\")\n+\n+# Add more authors with same name but different ages to show the issue\n+author3 = OrderedAuthor.objects.create(name=\"John Doe\", age=40)  # Same name as author1\n+OrderedBook.objects.create(title=\"Book 4\", author=author3)\n+\n+connection.queries_log.clear()\n+result_with_duplicates = list(OrderedAuthor.objects.annotate(book_count=Count('books')).values('name', 'book_count'))\n+\n+print(\"Results with duplicate names (with Meta.ordering):\")\n+for item in result_with_duplicates:\n+    print(f\"  {item}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL with duplicate names:\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+        if 'GROUP BY' in sql and '\"test_orderedauthor\".\"name\"' in sql:\n+            print(\"  *** ISSUE: Meta.ordering field 'name' is included in GROUP BY clause! ***\")\n+            print(\"  *** This causes incorrect aggregation when there are multiple records with same name! ***\")\n+\n+connection.queries_log.clear()\n+result_no_order_duplicates = list(OrderedAuthor.objects.annotate(book_count=Count('books')).order_by().values('name', 'book_count'))\n+\n+print(\"\\nResults with duplicate names (without ordering):\")\n+for item in result_no_order_duplicates:\n+    print(f\"  {item}\")\n+\n+if connection.queries:\n+    print(f\"\\nGenerated SQL with duplicate names (no ordering):\")\n+    for query in connection.queries:\n+        sql = query['sql']\n+        print(f\"  {sql}\")\n+\n+print(f\"\\nWith Meta.ordering and duplicates: {len(result_with_duplicates)} results\")\n+print(f\"Without ordering and duplicates: {len(result_no_order_duplicates)} results\")\n+if len(result_with_duplicates) != len(result_no_order_duplicates):\n+    print(\"*** ISSUE CONFIRMED: Different number of results due to Meta.ordering in GROUP BY! ***\")\n\\ No newline at end of file\n"}