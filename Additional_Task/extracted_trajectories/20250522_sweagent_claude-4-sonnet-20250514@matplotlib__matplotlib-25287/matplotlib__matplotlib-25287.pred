{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "matplotlib__matplotlib-25287", "model_patch": "diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py\nindex c0e706e2b3..0920063693 100644\n--- a/lib/matplotlib/axis.py\n+++ b/lib/matplotlib/axis.py\n@@ -2255,7 +2255,7 @@ class XAxis(Axis):\n             transform=mtransforms.blended_transform_factory(\n                 self.axes.transAxes, mtransforms.IdentityTransform()),\n             fontsize=mpl.rcParams['xtick.labelsize'],\n-            color=mpl.rcParams['xtick.color'],\n+            color=mpl.rcParams['xtick.color'] if mpl.rcParams['xtick.labelcolor']=='inherit' else mpl.rcParams['xtick.labelcolor'],\n         )\n         self.offset_text_position = 'bottom'\n \n@@ -2515,7 +2515,7 @@ class YAxis(Axis):\n             transform=mtransforms.blended_transform_factory(\n                 self.axes.transAxes, mtransforms.IdentityTransform()),\n             fontsize=mpl.rcParams['ytick.labelsize'],\n-            color=mpl.rcParams['ytick.color'],\n+            color=mpl.rcParams['ytick.color'] if mpl.rcParams['ytick.labelcolor']=='inherit' else mpl.rcParams['ytick.labelcolor'],\n         )\n         self.offset_text_position = 'left'\n \ndiff --git a/setup.py b/setup.py\ndeleted file mode 100644\nindex bbaa56f3d6..0000000000\n--- a/setup.py\n+++ /dev/null\n@@ -1,353 +0,0 @@\n-\"\"\"\n-The Matplotlib build options can be modified with a mplsetup.cfg file. See\n-mplsetup.cfg.template for more information.\n-\"\"\"\n-\n-# NOTE: This file must remain Python 2 compatible for the foreseeable future,\n-# to ensure that we error out properly for people with outdated setuptools\n-# and/or pip.\n-import sys\n-\n-py_min_version = (3, 9)  # minimal supported python version\n-since_mpl_version = (3, 8)  # py_min_version is required since this mpl version\n-\n-if sys.version_info < py_min_version:\n-    error = \"\"\"\n-Beginning with Matplotlib {0}, Python {1} or above is required.\n-You are using Python {2}.\n-\n-This may be due to an out of date pip.\n-\n-Make sure you have pip >= 9.0.1.\n-\"\"\".format('.'.join(str(n) for n in since_mpl_version),\n-           '.'.join(str(n) for n in py_min_version),\n-           '.'.join(str(n) for n in sys.version_info[:3]))\n-    sys.exit(error)\n-\n-import os\n-from pathlib import Path\n-import shutil\n-import subprocess\n-\n-from setuptools import setup, find_packages, Distribution, Extension\n-import setuptools.command.build_ext\n-import setuptools.command.build_py\n-import setuptools.command.sdist\n-\n-# sys.path modified to find setupext.py during pyproject.toml builds.\n-sys.path.append(str(Path(__file__).resolve().parent))\n-\n-import setupext\n-from setupext import print_raw, print_status\n-\n-\n-# These are the packages in the order we want to display them.\n-mpl_packages = [\n-    setupext.Matplotlib(),\n-    setupext.Python(),\n-    setupext.Platform(),\n-    setupext.FreeType(),\n-    setupext.Qhull(),\n-    setupext.Tests(),\n-    setupext.BackendMacOSX(),\n-    ]\n-\n-\n-# From https://bugs.python.org/issue26689\n-def has_flag(self, flagname):\n-    \"\"\"Return whether a flag name is supported on the specified compiler.\"\"\"\n-    import tempfile\n-    with tempfile.NamedTemporaryFile('w', suffix='.cpp') as f:\n-        f.write('int main (int argc, char **argv) { return 0; }')\n-        try:\n-            self.compile([f.name], extra_postargs=[flagname])\n-        except Exception as exc:\n-            # https://github.com/pypa/setuptools/issues/2698\n-            if type(exc).__name__ != \"CompileError\":\n-                raise\n-            return False\n-    return True\n-\n-\n-class BuildExtraLibraries(setuptools.command.build_ext.build_ext):\n-    def finalize_options(self):\n-        # If coverage is enabled then need to keep the .o and .gcno files in a\n-        # non-temporary directory otherwise coverage info not collected.\n-        cppflags = os.getenv('CPPFLAGS')\n-        if cppflags and '--coverage' in cppflags:\n-            self.build_temp = 'build'\n-\n-        self.distribution.ext_modules[:] = [\n-            ext\n-            for package in good_packages\n-            for ext in package.get_extensions()\n-        ]\n-        super().finalize_options()\n-\n-    def add_optimization_flags(self):\n-        \"\"\"\n-        Add optional optimization flags to extension.\n-\n-        This adds flags for LTO and hidden visibility to both compiled\n-        extensions, and to the environment variables so that vendored libraries\n-        will also use them. If the compiler does not support these flags, then\n-        none are added.\n-        \"\"\"\n-\n-        env = os.environ.copy()\n-        if sys.platform == 'win32':\n-            return env\n-        enable_lto = setupext.config.getboolean('libs', 'enable_lto',\n-                                                fallback=None)\n-\n-        def prepare_flags(name, enable_lto):\n-            \"\"\"\n-            Prepare *FLAGS from the environment.\n-\n-            If set, return them, and also check whether LTO is disabled in each\n-            one, raising an error if Matplotlib config explicitly enabled LTO.\n-            \"\"\"\n-            if name in os.environ:\n-                if '-fno-lto' in os.environ[name]:\n-                    if enable_lto is True:\n-                        raise ValueError('Configuration enable_lto=True, but '\n-                                         '{0} contains -fno-lto'.format(name))\n-                    enable_lto = False\n-                return [os.environ[name]], enable_lto\n-            return [], enable_lto\n-\n-        _, enable_lto = prepare_flags('CFLAGS', enable_lto)  # Only check lto.\n-        cppflags, enable_lto = prepare_flags('CPPFLAGS', enable_lto)\n-        cxxflags, enable_lto = prepare_flags('CXXFLAGS', enable_lto)\n-        ldflags, enable_lto = prepare_flags('LDFLAGS', enable_lto)\n-\n-        if enable_lto is False:\n-            return env\n-\n-        if has_flag(self.compiler, '-fvisibility=hidden'):\n-            for ext in self.extensions:\n-                ext.extra_compile_args.append('-fvisibility=hidden')\n-            cppflags.append('-fvisibility=hidden')\n-        if has_flag(self.compiler, '-fvisibility-inlines-hidden'):\n-            for ext in self.extensions:\n-                if self.compiler.detect_language(ext.sources) != 'cpp':\n-                    continue\n-                ext.extra_compile_args.append('-fvisibility-inlines-hidden')\n-            cxxflags.append('-fvisibility-inlines-hidden')\n-        ranlib = 'RANLIB' in env\n-        if not ranlib and self.compiler.compiler_type == 'unix':\n-            try:\n-                result = subprocess.run(self.compiler.compiler +\n-                                        ['--version'],\n-                                        stdout=subprocess.PIPE,\n-                                        stderr=subprocess.STDOUT,\n-                                        universal_newlines=True)\n-            except Exception:\n-                pass\n-            else:\n-                version = result.stdout.lower()\n-                if 'gcc' in version:\n-                    ranlib = shutil.which('gcc-ranlib')\n-                elif 'clang' in version:\n-                    if sys.platform == 'darwin':\n-                        ranlib = True\n-                    else:\n-                        ranlib = shutil.which('llvm-ranlib')\n-        if ranlib and has_flag(self.compiler, '-flto'):\n-            for ext in self.extensions:\n-                ext.extra_compile_args.append('-flto')\n-            cppflags.append('-flto')\n-            ldflags.append('-flto')\n-            # Needed so FreeType static library doesn't lose its LTO objects.\n-            if isinstance(ranlib, str):\n-                env['RANLIB'] = ranlib\n-\n-        env['CPPFLAGS'] = ' '.join(cppflags)\n-        env['CXXFLAGS'] = ' '.join(cxxflags)\n-        env['LDFLAGS'] = ' '.join(ldflags)\n-\n-        return env\n-\n-    def build_extensions(self):\n-        if (self.compiler.compiler_type == 'msvc' and\n-                os.environ.get('MPL_DISABLE_FH4')):\n-            # Disable FH4 Exception Handling implementation so that we don't\n-            # require VCRUNTIME140_1.dll. For more details, see:\n-            # https://devblogs.microsoft.com/cppblog/making-cpp-exception-handling-smaller-x64/\n-            # https://github.com/joerick/cibuildwheel/issues/423#issuecomment-677763904\n-            for ext in self.extensions:\n-                ext.extra_compile_args.append('/d2FH4-')\n-\n-        env = self.add_optimization_flags()\n-        for package in good_packages:\n-            package.do_custom_build(env)\n-        return super().build_extensions()\n-\n-    def build_extension(self, ext):\n-        # When C coverage is enabled, the path to the object file is saved.\n-        # Since we re-use source files in multiple extensions, libgcov will\n-        # complain at runtime that it is trying to save coverage for the same\n-        # object file at different timestamps (since each source is compiled\n-        # again for each extension). Thus, we need to use unique temporary\n-        # build directories to store object files for each extension.\n-        orig_build_temp = self.build_temp\n-        self.build_temp = os.path.join(self.build_temp, ext.name)\n-        try:\n-            super().build_extension(ext)\n-        finally:\n-            self.build_temp = orig_build_temp\n-\n-\n-def update_matplotlibrc(path):\n-    # If packagers want to change the default backend, insert a `#backend: ...`\n-    # line.  Otherwise, use the default `##backend: Agg` which has no effect\n-    # even after decommenting, which allows _auto_backend_sentinel to be filled\n-    # in at import time.\n-    template_lines = path.read_text(encoding=\"utf-8\").splitlines(True)\n-    backend_line_idx, = [  # Also asserts that there is a single such line.\n-        idx for idx, line in enumerate(template_lines)\n-        if \"#backend:\" in line]\n-    template_lines[backend_line_idx] = (\n-        \"#backend: {}\\n\".format(setupext.options[\"backend\"])\n-        if setupext.options[\"backend\"]\n-        else \"##backend: Agg\\n\")\n-    path.write_text(\"\".join(template_lines), encoding=\"utf-8\")\n-\n-\n-class BuildPy(setuptools.command.build_py.build_py):\n-    def run(self):\n-        super().run()\n-        if not getattr(self, 'editable_mode', False):\n-            update_matplotlibrc(\n-                Path(self.build_lib, \"matplotlib/mpl-data/matplotlibrc\"))\n-\n-\n-class Sdist(setuptools.command.sdist.sdist):\n-    def make_release_tree(self, base_dir, files):\n-        super().make_release_tree(base_dir, files)\n-        update_matplotlibrc(\n-            Path(base_dir, \"lib/matplotlib/mpl-data/matplotlibrc\"))\n-\n-\n-package_data = {}  # Will be filled below by the various components.\n-\n-# If the user just queries for information, don't bother figuring out which\n-# packages to build or install.\n-if not (any('--' + opt in sys.argv\n-            for opt in Distribution.display_option_names + ['help'])\n-        or 'clean' in sys.argv):\n-    # Go through all of the packages and figure out which ones we are\n-    # going to build/install.\n-    print_raw()\n-    print_raw(\"Edit mplsetup.cfg to change the build options; \"\n-              \"suppress output with --quiet.\")\n-    print_raw()\n-    print_raw(\"BUILDING MATPLOTLIB\")\n-\n-    good_packages = []\n-    for package in mpl_packages:\n-        try:\n-            message = package.check()\n-        except setupext.Skipped as e:\n-            print_status(package.name, \"no  [{e}]\".format(e=e))\n-            continue\n-        if message is not None:\n-            print_status(package.name,\n-                         \"yes [{message}]\".format(message=message))\n-        good_packages.append(package)\n-\n-    print_raw()\n-\n-    # Now collect all of the information we need to build all of the packages.\n-    for package in good_packages:\n-        # Extension modules only get added in build_ext, as numpy will have\n-        # been installed (as setup_requires) at that point.\n-        data = package.get_package_data()\n-        for key, val in data.items():\n-            package_data.setdefault(key, [])\n-            package_data[key] = list(set(val + package_data[key]))\n-\n-setup(  # Finally, pass this all along to setuptools to do the heavy lifting.\n-    name=\"matplotlib\",\n-    description=\"Python plotting package\",\n-    author=\"John D. Hunter, Michael Droettboom\",\n-    author_email=\"matplotlib-users@python.org\",\n-    url=\"https://matplotlib.org\",\n-    download_url=\"https://matplotlib.org/stable/users/installing/index.html\",\n-    project_urls={\n-        'Documentation': 'https://matplotlib.org',\n-        'Source Code': 'https://github.com/matplotlib/matplotlib',\n-        'Bug Tracker': 'https://github.com/matplotlib/matplotlib/issues',\n-        'Forum': 'https://discourse.matplotlib.org/',\n-        'Donate': 'https://numfocus.org/donate-to-matplotlib'\n-    },\n-    long_description=Path(\"README.md\").read_text(encoding=\"utf-8\"),\n-    long_description_content_type=\"text/markdown\",\n-    license=\"PSF\",\n-    platforms=\"any\",\n-    classifiers=[\n-        'Development Status :: 5 - Production/Stable',\n-        'Framework :: Matplotlib',\n-        'Intended Audience :: Science/Research',\n-        'Intended Audience :: Education',\n-        'License :: OSI Approved :: Python Software Foundation License',\n-        'Programming Language :: Python',\n-        'Programming Language :: Python :: 3',\n-        'Programming Language :: Python :: 3.9',\n-        'Programming Language :: Python :: 3.10',\n-        'Programming Language :: Python :: 3.11',\n-        'Topic :: Scientific/Engineering :: Visualization',\n-    ],\n-\n-    package_dir={\"\": \"lib\"},\n-    packages=find_packages(\"lib\"),\n-    namespace_packages=[\"mpl_toolkits\"],\n-    py_modules=[\"pylab\"],\n-    # Dummy extension to trigger build_ext, which will swap it out with\n-    # real extensions that can depend on numpy for the build.\n-    ext_modules=[Extension(\"\", [])],\n-    package_data=package_data,\n-\n-    python_requires='>={}'.format('.'.join(str(n) for n in py_min_version)),\n-    # When updating the list of dependencies, add an api_changes/development\n-    # entry and also update the following places:\n-    # - lib/matplotlib/__init__.py (matplotlib._check_versions())\n-    # - requirements/testing/minver.txt\n-    # - doc/devel/dependencies.rst\n-    # - .github/workflows/tests.yml\n-    # - environment.yml\n-    install_requires=[\n-        \"contourpy>=1.0.1\",\n-        \"cycler>=0.10\",\n-        \"fonttools>=4.22.0\",\n-        \"kiwisolver>=1.0.1\",\n-        \"numpy>=1.21\",\n-        \"packaging>=20.0\",\n-        \"pillow>=6.2.0\",\n-        \"pyparsing>=2.3.1\",\n-        \"python-dateutil>=2.7\",\n-    ] + (\n-        # Installing from a git checkout that is not producing a wheel.\n-        [\"setuptools_scm>=7\"] if (\n-            Path(__file__).with_name(\".git\").exists() and\n-            os.environ.get(\"CIBUILDWHEEL\", \"0\") != \"1\"\n-        ) else []\n-    ),\n-    extras_require={\n-        ':python_version<\"3.10\"': [\n-            \"importlib-resources>=3.2.0\",\n-        ],\n-    },\n-    use_scm_version={\n-        \"version_scheme\": \"release-branch-semver\",\n-        \"local_scheme\": \"node-and-date\",\n-        \"write_to\": \"lib/matplotlib/_version.py\",\n-        \"parentdir_prefix_version\": \"matplotlib-\",\n-        \"fallback_version\": \"0.0+UNKNOWN\",\n-    },\n-    cmdclass={\n-        \"build_ext\": BuildExtraLibraries,\n-        \"build_py\": BuildPy,\n-        \"sdist\": Sdist,\n-    },\n-)\ndiff --git a/setupext.py b/setupext.py\ndeleted file mode 100644\nindex 7cd5216a59..0000000000\n--- a/setupext.py\n+++ /dev/null\n@@ -1,796 +0,0 @@\n-import configparser\n-import functools\n-import hashlib\n-from io import BytesIO\n-import logging\n-import os\n-from pathlib import Path\n-import platform\n-import shlex\n-import shutil\n-import subprocess\n-import sys\n-import sysconfig\n-import tarfile\n-from tempfile import TemporaryDirectory\n-import textwrap\n-import urllib.request\n-\n-from pybind11.setup_helpers import Pybind11Extension\n-from setuptools import Distribution, Extension\n-\n-_log = logging.getLogger(__name__)\n-\n-\n-def _get_xdg_cache_dir():\n-    \"\"\"\n-    Return the `XDG cache directory`__.\n-\n-    __ https://specifications.freedesktop.org/basedir-spec/latest/\n-    \"\"\"\n-    cache_dir = os.environ.get('XDG_CACHE_HOME')\n-    if not cache_dir:\n-        cache_dir = os.path.expanduser('~/.cache')\n-        if cache_dir.startswith('~/'):  # Expansion failed.\n-            return None\n-    return Path(cache_dir, 'matplotlib')\n-\n-\n-def _get_hash(data):\n-    \"\"\"Compute the sha256 hash of *data*.\"\"\"\n-    hasher = hashlib.sha256()\n-    hasher.update(data)\n-    return hasher.hexdigest()\n-\n-\n-@functools.cache\n-def _get_ssl_context():\n-    import certifi\n-    import ssl\n-    return ssl.create_default_context(cafile=certifi.where())\n-\n-\n-def get_from_cache_or_download(url, sha):\n-    \"\"\"\n-    Get bytes from the given url or local cache.\n-\n-    Parameters\n-    ----------\n-    url : str\n-        The url to download.\n-    sha : str\n-        The sha256 of the file.\n-\n-    Returns\n-    -------\n-    BytesIO\n-        The file loaded into memory.\n-    \"\"\"\n-    cache_dir = _get_xdg_cache_dir()\n-\n-    if cache_dir is not None:  # Try to read from cache.\n-        try:\n-            data = (cache_dir / sha).read_bytes()\n-        except OSError:\n-            pass\n-        else:\n-            if _get_hash(data) == sha:\n-                return BytesIO(data)\n-\n-    # jQueryUI's website blocks direct downloads from urllib.request's\n-    # default User-Agent, but not (for example) wget; so I don't feel too\n-    # bad passing in an empty User-Agent.\n-    with urllib.request.urlopen(\n-            urllib.request.Request(url, headers={\"User-Agent\": \"\"}),\n-            context=_get_ssl_context()) as req:\n-        data = req.read()\n-\n-    file_sha = _get_hash(data)\n-    if file_sha != sha:\n-        raise Exception(\n-            f\"The downloaded file does not match the expected sha.  {url} was \"\n-            f\"expected to have {sha} but it had {file_sha}\")\n-\n-    if cache_dir is not None:  # Try to cache the downloaded file.\n-        try:\n-            cache_dir.mkdir(parents=True, exist_ok=True)\n-            with open(cache_dir / sha, \"xb\") as fout:\n-                fout.write(data)\n-        except OSError:\n-            pass\n-\n-    return BytesIO(data)\n-\n-\n-def get_and_extract_tarball(urls, sha, dirname):\n-    \"\"\"\n-    Obtain a tarball (from cache or download) and extract it.\n-\n-    Parameters\n-    ----------\n-    urls : list[str]\n-        URLs from which download is attempted (in order of attempt), if the\n-        tarball is not in the cache yet.\n-    sha : str\n-        SHA256 hash of the tarball; used both as a cache key (by\n-        `get_from_cache_or_download`) and to validate a downloaded tarball.\n-    dirname : path-like\n-        Directory where the tarball is extracted.\n-    \"\"\"\n-    toplevel = Path(\"build\", dirname)\n-    if not toplevel.exists():  # Download it or load it from cache.\n-        try:\n-            import certifi  # noqa\n-        except ImportError as e:\n-            raise ImportError(\n-                f\"`certifi` is unavailable ({e}) so unable to download any of \"\n-                f\"the following: {urls}.\") from None\n-\n-        Path(\"build\").mkdir(exist_ok=True)\n-        for url in urls:\n-            try:\n-                tar_contents = get_from_cache_or_download(url, sha)\n-                break\n-            except Exception:\n-                pass\n-        else:\n-            raise OSError(\n-                f\"Failed to download any of the following: {urls}.  \"\n-                f\"Please download one of these urls and extract it into \"\n-                f\"'build/' at the top-level of the source repository.\")\n-        print(f\"Extracting {urllib.parse.urlparse(url).path}\")\n-        with tarfile.open(fileobj=tar_contents, mode=\"r:gz\") as tgz:\n-            if os.path.commonpath(tgz.getnames()) != dirname:\n-                raise OSError(\n-                    f\"The downloaded tgz file was expected to have {dirname} \"\n-                    f\"as sole top-level directory, but that is not the case\")\n-            tgz.extractall(\"build\")\n-    return toplevel\n-\n-\n-# SHA256 hashes of the FreeType tarballs\n-_freetype_hashes = {\n-    '2.6.1':\n-        '0a3c7dfbda6da1e8fce29232e8e96d987ababbbf71ebc8c75659e4132c367014',\n-    '2.6.2':\n-        '8da42fc4904e600be4b692555ae1dcbf532897da9c5b9fb5ebd3758c77e5c2d4',\n-    '2.6.3':\n-        '7942096c40ee6fea882bd4207667ad3f24bff568b96b10fd3885e11a7baad9a3',\n-    '2.6.4':\n-        '27f0e38347a1850ad57f84fc4dfed68ba0bc30c96a6fa6138ef84d485dd9a8d7',\n-    '2.6.5':\n-        '3bb24add9b9ec53636a63ea8e867ed978c4f8fdd8f1fa5ccfd41171163d4249a',\n-    '2.7':\n-        '7b657d5f872b0ab56461f3bd310bd1c5ec64619bd15f0d8e08282d494d9cfea4',\n-    '2.7.1':\n-        '162ef25aa64480b1189cdb261228e6c5c44f212aac4b4621e28cf2157efb59f5',\n-    '2.8':\n-        '33a28fabac471891d0523033e99c0005b95e5618dc8ffa7fa47f9dadcacb1c9b',\n-    '2.8.1':\n-        '876711d064a6a1bd74beb18dd37f219af26100f72daaebd2d86cb493d7cd7ec6',\n-    '2.9':\n-        'bf380e4d7c4f3b5b1c1a7b2bf3abb967bda5e9ab480d0df656e0e08c5019c5e6',\n-    '2.9.1':\n-        'ec391504e55498adceb30baceebd147a6e963f636eb617424bcfc47a169898ce',\n-    '2.10.0':\n-        '955e17244e9b38adb0c98df66abb50467312e6bb70eac07e49ce6bd1a20e809a',\n-    '2.10.1':\n-        '3a60d391fd579440561bf0e7f31af2222bc610ad6ce4d9d7bd2165bca8669110',\n-    '2.11.1':\n-        'f8db94d307e9c54961b39a1cc799a67d46681480696ed72ecf78d4473770f09b'\n-}\n-# This is the version of FreeType to use when building a local version.  It\n-# must match the value in lib/matplotlib.__init__.py, and the cache path in\n-# `.circleci/config.yml`.\n-TESTING_VERSION_OF_FREETYPE = '2.6.1'\n-if sys.platform.startswith('win') and platform.machine() == 'ARM64':\n-    # older versions of freetype are not supported for win/arm64\n-    # Matplotlib tests will not pass\n-    LOCAL_FREETYPE_VERSION = '2.11.1'\n-else:\n-    LOCAL_FREETYPE_VERSION = TESTING_VERSION_OF_FREETYPE\n-\n-LOCAL_FREETYPE_HASH = _freetype_hashes.get(LOCAL_FREETYPE_VERSION, 'unknown')\n-\n-# Also update the cache path in `.circleci/config.yml`.\n-LOCAL_QHULL_VERSION = '2020.2'\n-LOCAL_QHULL_HASH = (\n-    'b5c2d7eb833278881b952c8a52d20179eab87766b00b865000469a45c1838b7e')\n-\n-\n-# Matplotlib build options, which can be altered using mplsetup.cfg\n-mplsetup_cfg = os.environ.get('MPLSETUPCFG') or 'mplsetup.cfg'\n-config = configparser.ConfigParser()\n-if os.path.exists(mplsetup_cfg):\n-    config.read(mplsetup_cfg)\n-options = {\n-    'backend': config.get('rc_options', 'backend', fallback=None),\n-    'system_freetype': config.getboolean(\n-        'libs', 'system_freetype',\n-        fallback=sys.platform.startswith(('aix', 'os400'))\n-    ),\n-    'system_qhull': config.getboolean(\n-        'libs', 'system_qhull', fallback=sys.platform.startswith('os400')\n-    ),\n-}\n-\n-\n-if '-q' in sys.argv or '--quiet' in sys.argv:\n-    def print_raw(*args, **kwargs): pass  # Suppress our own output.\n-else:\n-    print_raw = print\n-\n-\n-def print_status(package, status):\n-    initial_indent = \"%12s: \" % package\n-    indent = ' ' * 18\n-    print_raw(textwrap.fill(status, width=80,\n-                            initial_indent=initial_indent,\n-                            subsequent_indent=indent))\n-\n-\n-@functools.cache  # We only need to compute this once.\n-def get_pkg_config():\n-    \"\"\"\n-    Get path to pkg-config and set up the PKG_CONFIG environment variable.\n-    \"\"\"\n-    if sys.platform == 'win32':\n-        return None\n-    pkg_config = os.environ.get('PKG_CONFIG') or 'pkg-config'\n-    if shutil.which(pkg_config) is None:\n-        print(\n-            \"IMPORTANT WARNING:\\n\"\n-            \"    pkg-config is not installed.\\n\"\n-            \"    Matplotlib may not be able to find some of its dependencies.\")\n-        return None\n-    pkg_config_path = sysconfig.get_config_var('LIBDIR')\n-    if pkg_config_path is not None:\n-        pkg_config_path = os.path.join(pkg_config_path, 'pkgconfig')\n-        try:\n-            os.environ['PKG_CONFIG_PATH'] += ':' + pkg_config_path\n-        except KeyError:\n-            os.environ['PKG_CONFIG_PATH'] = pkg_config_path\n-    return pkg_config\n-\n-\n-def pkg_config_setup_extension(\n-        ext, package,\n-        atleast_version=None, alt_exec=None, default_libraries=()):\n-    \"\"\"Add parameters to the given *ext* for the given *package*.\"\"\"\n-\n-    # First, try to get the flags from pkg-config.\n-\n-    pkg_config = get_pkg_config()\n-    cmd = [pkg_config, package] if pkg_config else alt_exec\n-    if cmd is not None:\n-        try:\n-            if pkg_config and atleast_version:\n-                subprocess.check_call(\n-                    [*cmd, f\"--atleast-version={atleast_version}\"])\n-            # Use sys.getfilesystemencoding() to allow round-tripping\n-            # when passed back to later subprocess calls; do not use\n-            # locale.getpreferredencoding() which universal_newlines=True\n-            # would do.\n-            cflags = shlex.split(\n-                os.fsdecode(subprocess.check_output([*cmd, \"--cflags\"])))\n-            libs = shlex.split(\n-                os.fsdecode(subprocess.check_output([*cmd, \"--libs\"])))\n-        except (OSError, subprocess.CalledProcessError):\n-            pass\n-        else:\n-            ext.extra_compile_args.extend(cflags)\n-            ext.extra_link_args.extend(libs)\n-            return\n-\n-    # If that fails, fall back on the defaults.\n-\n-    # conda Windows header and library paths.\n-    # https://github.com/conda/conda/issues/2312 re: getting the env dir.\n-    if sys.platform == 'win32':\n-        conda_env_path = (os.getenv('CONDA_PREFIX')  # conda >= 4.1\n-                          or os.getenv('CONDA_DEFAULT_ENV'))  # conda < 4.1\n-        if conda_env_path and os.path.isdir(conda_env_path):\n-            conda_env_path = Path(conda_env_path)\n-            ext.include_dirs.append(str(conda_env_path / \"Library/include\"))\n-            ext.library_dirs.append(str(conda_env_path / \"Library/lib\"))\n-\n-    # Default linked libs.\n-    ext.libraries.extend(default_libraries)\n-\n-\n-class Skipped(Exception):\n-    \"\"\"\n-    Exception thrown by `SetupPackage.check` to indicate that a package should\n-    be skipped.\n-    \"\"\"\n-\n-\n-class SetupPackage:\n-\n-    def check(self):\n-        \"\"\"\n-        If the package should be installed, return an informative string, or\n-        None if no information should be displayed at all.\n-\n-        If the package should be skipped, raise a `Skipped` exception.\n-\n-        If a missing build dependency is fatal, call `sys.exit`.\n-        \"\"\"\n-\n-    def get_package_data(self):\n-        \"\"\"\n-        Get a package data dictionary to add to the configuration.\n-        These are merged into to the *package_data* list passed to\n-        `setuptools.setup`.\n-        \"\"\"\n-        return {}\n-\n-    def get_extensions(self):\n-        \"\"\"\n-        Return or yield a list of C extensions (`distutils.core.Extension`\n-        objects) to add to the configuration.  These are added to the\n-        *extensions* list passed to `setuptools.setup`.\n-        \"\"\"\n-        return []\n-\n-    def do_custom_build(self, env):\n-        \"\"\"\n-        If a package needs to do extra custom things, such as building a\n-        third-party library, before building an extension, it should\n-        override this method.\n-        \"\"\"\n-\n-\n-class OptionalPackage(SetupPackage):\n-    default_config = True\n-\n-    def check(self):\n-        \"\"\"\n-        Check whether ``mplsetup.cfg`` requests this package to be installed.\n-\n-        May be overridden by subclasses for additional checks.\n-        \"\"\"\n-        if config.getboolean(\"packages\", self.name,\n-                             fallback=self.default_config):\n-            return \"installing\"\n-        else:  # Configuration opt-out by user\n-            raise Skipped(\"skipping due to configuration\")\n-\n-\n-class Platform(SetupPackage):\n-    name = \"platform\"\n-\n-    def check(self):\n-        return sys.platform\n-\n-\n-class Python(SetupPackage):\n-    name = \"python\"\n-\n-    def check(self):\n-        return sys.version\n-\n-\n-def _pkg_data_helper(pkg, subdir):\n-    \"\"\"Glob \"lib/$pkg/$subdir/**/*\", returning paths relative to \"lib/$pkg\".\"\"\"\n-    base = Path(\"lib\", pkg)\n-    return [str(path.relative_to(base)) for path in (base / subdir).rglob(\"*\")]\n-\n-\n-class Matplotlib(SetupPackage):\n-    name = \"matplotlib\"\n-\n-    def get_package_data(self):\n-        return {\n-            'matplotlib': [\n-                'mpl-data/matplotlibrc',\n-                *_pkg_data_helper('matplotlib', 'mpl-data'),\n-                *_pkg_data_helper('matplotlib', 'backends/web_backend'),\n-                '*.dll',  # Only actually matters on Windows.\n-            ],\n-        }\n-\n-    def get_extensions(self):\n-        # agg\n-        ext = Extension(\n-            \"matplotlib.backends._backend_agg\", [\n-                \"src/py_converters.cpp\",\n-                \"src/_backend_agg.cpp\",\n-                \"src/_backend_agg_wrapper.cpp\",\n-            ])\n-        add_numpy_flags(ext)\n-        add_libagg_flags_and_sources(ext)\n-        FreeType.add_flags(ext)\n-        yield ext\n-        # c_internal_utils\n-        ext = Extension(\n-            \"matplotlib._c_internal_utils\", [\"src/_c_internal_utils.c\"],\n-            libraries=({\n-                \"linux\": [\"dl\"],\n-                \"win32\": [\"ole32\", \"shell32\", \"user32\"],\n-            }.get(sys.platform, [])))\n-        yield ext\n-        # ft2font\n-        ext = Extension(\n-            \"matplotlib.ft2font\", [\n-                \"src/ft2font.cpp\",\n-                \"src/ft2font_wrapper.cpp\",\n-                \"src/py_converters.cpp\",\n-            ])\n-        FreeType.add_flags(ext)\n-        add_numpy_flags(ext)\n-        add_libagg_flags(ext)\n-        yield ext\n-        # image\n-        ext = Extension(\n-            \"matplotlib._image\", [\n-                \"src/_image_wrapper.cpp\",\n-                \"src/py_converters.cpp\",\n-            ])\n-        add_numpy_flags(ext)\n-        add_libagg_flags_and_sources(ext)\n-        yield ext\n-        # path\n-        ext = Extension(\n-            \"matplotlib._path\", [\n-                \"src/py_converters.cpp\",\n-                \"src/_path_wrapper.cpp\",\n-            ])\n-        add_numpy_flags(ext)\n-        add_libagg_flags_and_sources(ext)\n-        yield ext\n-        # qhull\n-        ext = Extension(\n-            \"matplotlib._qhull\", [\"src/_qhull_wrapper.cpp\"],\n-            define_macros=[(\"MPL_DEVNULL\", os.devnull)])\n-        add_numpy_flags(ext)\n-        Qhull.add_flags(ext)\n-        yield ext\n-        # tkagg\n-        ext = Extension(\n-            \"matplotlib.backends._tkagg\", [\n-                \"src/_tkagg.cpp\",\n-            ],\n-            include_dirs=[\"src\"],\n-            # psapi library needed for finding Tcl/Tk at run time.\n-            libraries={\"linux\": [\"dl\"], \"win32\": [\"comctl32\", \"psapi\"],\n-                       \"cygwin\": [\"comctl32\", \"psapi\"]}.get(sys.platform, []),\n-            extra_link_args={\"win32\": [\"-mwindows\"]}.get(sys.platform, []))\n-        add_numpy_flags(ext)\n-        add_libagg_flags(ext)\n-        yield ext\n-        # tri\n-        ext = Pybind11Extension(\n-            \"matplotlib._tri\", [\n-                \"src/tri/_tri.cpp\",\n-                \"src/tri/_tri_wrapper.cpp\",\n-            ],\n-            cxx_std=11)\n-        yield ext\n-        # ttconv\n-        ext = Extension(\n-            \"matplotlib._ttconv\", [\n-                \"src/_ttconv.cpp\",\n-                \"extern/ttconv/pprdrv_tt.cpp\",\n-                \"extern/ttconv/pprdrv_tt2.cpp\",\n-                \"extern/ttconv/ttutil.cpp\",\n-            ],\n-            include_dirs=[\"extern\"])\n-        add_numpy_flags(ext)\n-        yield ext\n-\n-\n-class Tests(OptionalPackage):\n-    name = \"tests\"\n-    default_config = False\n-\n-    def get_package_data(self):\n-        return {\n-            'matplotlib': [\n-                *_pkg_data_helper('matplotlib', 'tests/baseline_images'),\n-                *_pkg_data_helper('matplotlib', 'tests/tinypages'),\n-                'tests/cmr10.pfb',\n-                'tests/Courier10PitchBT-Bold.pfb',\n-                'tests/mpltest.ttf',\n-                'tests/test_*.ipynb',\n-            ],\n-            'mpl_toolkits': [\n-                *_pkg_data_helper('mpl_toolkits',\n-                                  'axes_grid1/tests/baseline_images'),\n-                *_pkg_data_helper('mpl_toolkits',\n-                                  'axisartist/tests/baseline_images'),\n-                *_pkg_data_helper('mpl_toolkits',\n-                                  'mplot3d/tests/baseline_images'),\n-            ]\n-        }\n-\n-\n-def add_numpy_flags(ext):\n-    import numpy as np\n-    ext.include_dirs.append(np.get_include())\n-    ext.define_macros.extend([\n-        # Ensure that PY_ARRAY_UNIQUE_SYMBOL is uniquely defined for each\n-        # extension.\n-        ('PY_ARRAY_UNIQUE_SYMBOL',\n-         'MPL_' + ext.name.replace('.', '_') + '_ARRAY_API'),\n-        ('NPY_NO_DEPRECATED_API', 'NPY_1_7_API_VERSION'),\n-        # Allow NumPy's printf format specifiers in C++.\n-        ('__STDC_FORMAT_MACROS', 1),\n-    ])\n-\n-\n-def add_libagg_flags(ext):\n-    # We need a patched Agg not available elsewhere, so always use the vendored\n-    # version.\n-    ext.include_dirs.insert(0, \"extern/agg24-svn/include\")\n-\n-\n-def add_libagg_flags_and_sources(ext):\n-    # We need a patched Agg not available elsewhere, so always use the vendored\n-    # version.\n-    ext.include_dirs.insert(0, \"extern/agg24-svn/include\")\n-    agg_sources = [\n-        \"agg_bezier_arc.cpp\",\n-        \"agg_curves.cpp\",\n-        \"agg_image_filters.cpp\",\n-        \"agg_trans_affine.cpp\",\n-        \"agg_vcgen_contour.cpp\",\n-        \"agg_vcgen_dash.cpp\",\n-        \"agg_vcgen_stroke.cpp\",\n-        \"agg_vpgen_segmentator.cpp\",\n-    ]\n-    ext.sources.extend(\n-        os.path.join(\"extern\", \"agg24-svn\", \"src\", x) for x in agg_sources)\n-\n-\n-def get_ccompiler():\n-    \"\"\"\n-    Return a new CCompiler instance.\n-\n-    CCompiler used to be constructible via `distutils.ccompiler.new_compiler`,\n-    but this API was removed as part of the distutils deprecation.  Instead,\n-    we trick setuptools into instantiating it by creating a dummy Distribution\n-    with a list of extension modules that claims to be truthy, but is actually\n-    empty, and then running the Distribution's build_ext command.  (If using\n-    a plain empty ext_modules, build_ext would early-return without doing\n-    anything.)\n-    \"\"\"\n-\n-    class L(list):\n-        def __bool__(self):\n-            return True\n-\n-    build_ext = Distribution({\"ext_modules\": L()}).get_command_obj(\"build_ext\")\n-    build_ext.finalize_options()\n-    build_ext.run()\n-    return build_ext.compiler\n-\n-\n-class FreeType(SetupPackage):\n-    name = \"freetype\"\n-\n-    @classmethod\n-    def add_flags(cls, ext):\n-        # checkdep_freetype2.c immediately aborts the compilation either with\n-        # \"foo.h: No such file or directory\" if the header is not found, or an\n-        # appropriate error message if the header indicates a too-old version.\n-        ext.sources.insert(0, 'src/checkdep_freetype2.c')\n-        if options.get('system_freetype'):\n-            pkg_config_setup_extension(\n-                # FreeType 2.3 has libtool version 9.11.3 as can be checked\n-                # from the tarball.  For FreeType>=2.4, there is a conversion\n-                # table in docs/VERSIONS.txt in the FreeType source tree.\n-                ext, 'freetype2',\n-                atleast_version='9.11.3',\n-                alt_exec=['freetype-config'],\n-                default_libraries=['freetype'])\n-            ext.define_macros.append(('FREETYPE_BUILD_TYPE', 'system'))\n-        else:\n-            src_path = Path('build', f'freetype-{LOCAL_FREETYPE_VERSION}')\n-            # Statically link to the locally-built freetype.\n-            ext.include_dirs.insert(0, str(src_path / 'include'))\n-            ext.extra_objects.insert(\n-                0, str((src_path / 'objs/.libs/libfreetype').with_suffix(\n-                    '.lib' if sys.platform == 'win32' else '.a')))\n-            ext.define_macros.append(('FREETYPE_BUILD_TYPE', 'local'))\n-            if sys.platform == 'darwin':\n-                name = ext.name.split('.')[-1]\n-                ext.extra_link_args.append(\n-                    f'-Wl,-exported_symbol,_PyInit_{name}')\n-\n-    def do_custom_build(self, env):\n-        # We're using a system freetype\n-        if options.get('system_freetype'):\n-            return\n-\n-        tarball = f'freetype-{LOCAL_FREETYPE_VERSION}.tar.gz'\n-        src_path = get_and_extract_tarball(\n-            urls=[\n-                (f'https://downloads.sourceforge.net/project/freetype'\n-                 f'/freetype2/{LOCAL_FREETYPE_VERSION}/{tarball}'),\n-                (f'https://download.savannah.gnu.org/releases/freetype'\n-                 f'/{tarball}'),\n-                (f'https://download.savannah.gnu.org/releases/freetype'\n-                 f'/freetype-old/{tarball}')\n-            ],\n-            sha=LOCAL_FREETYPE_HASH,\n-            dirname=f'freetype-{LOCAL_FREETYPE_VERSION}',\n-        )\n-\n-        libfreetype = (src_path / \"objs/.libs/libfreetype\").with_suffix(\n-            \".lib\" if sys.platform == \"win32\" else \".a\")\n-        if libfreetype.is_file():\n-            return  # Bail out because we have already built FreeType.\n-\n-        print(f\"Building freetype in {src_path}\")\n-        if sys.platform != 'win32':  # compilation on non-windows\n-            env = {\n-                **{\n-                    var: value\n-                    for var, value in sysconfig.get_config_vars().items()\n-                    if var in {\"CC\", \"CFLAGS\", \"CXX\", \"CXXFLAGS\", \"LD\",\n-                               \"LDFLAGS\"}\n-                },\n-                **env,\n-            }\n-            configure_ac = Path(src_path, \"builds/unix/configure.ac\")\n-            if ((src_path / \"autogen.sh\").exists()\n-                    and not configure_ac.exists()):\n-                print(f\"{configure_ac} does not exist. \"\n-                      f\"Using sh autogen.sh to generate.\")\n-                subprocess.check_call(\n-                    [\"sh\", \"./autogen.sh\"], env=env, cwd=src_path)\n-            env[\"CFLAGS\"] = env.get(\"CFLAGS\", \"\") + \" -fPIC\"\n-            configure = [\n-                \"./configure\", \"--with-zlib=no\", \"--with-bzip2=no\",\n-                \"--with-png=no\", \"--with-harfbuzz=no\", \"--enable-static\",\n-                \"--disable-shared\"\n-            ]\n-            host = sysconfig.get_config_var('HOST_GNU_TYPE')\n-            if host is not None:  # May be unset on PyPy.\n-                configure.append(f\"--host={host}\")\n-            subprocess.check_call(configure, env=env, cwd=src_path)\n-            if 'GNUMAKE' in env:\n-                make = env['GNUMAKE']\n-            elif 'MAKE' in env:\n-                make = env['MAKE']\n-            else:\n-                try:\n-                    output = subprocess.check_output(['make', '-v'],\n-                                                     stderr=subprocess.DEVNULL)\n-                except subprocess.CalledProcessError:\n-                    output = b''\n-                if b'GNU' not in output and b'makepp' not in output:\n-                    make = 'gmake'\n-                else:\n-                    make = 'make'\n-            subprocess.check_call([make], env=env, cwd=src_path)\n-        else:  # compilation on windows\n-            shutil.rmtree(src_path / \"objs\", ignore_errors=True)\n-            base_path = Path(\n-                f\"build/freetype-{LOCAL_FREETYPE_VERSION}/builds/windows\"\n-            )\n-            vc = 'vc2010'\n-            sln_path = base_path / vc / \"freetype.sln\"\n-            # https://developercommunity.visualstudio.com/comments/190992/view.html\n-            (sln_path.parent / \"Directory.Build.props\").write_text(\n-                \"<?xml version='1.0' encoding='utf-8'?>\"\n-                \"<Project>\"\n-                \"<PropertyGroup>\"\n-                # WindowsTargetPlatformVersion must be given on a single line.\n-                \"<WindowsTargetPlatformVersion>$(\"\n-                \"[Microsoft.Build.Utilities.ToolLocationHelper]\"\n-                \"::GetLatestSDKTargetPlatformVersion('Windows', '10.0')\"\n-                \")</WindowsTargetPlatformVersion>\"\n-                \"</PropertyGroup>\"\n-                \"</Project>\",\n-                encoding=\"utf-8\")\n-            # It is not a trivial task to determine PlatformToolset to plug it\n-            # into msbuild command, and Directory.Build.props will not override\n-            # the value in the project file.\n-            # The DefaultPlatformToolset is from Microsoft.Cpp.Default.props\n-            with open(base_path / vc / \"freetype.vcxproj\", 'r+b') as f:\n-                toolset_repl = b'PlatformToolset>$(DefaultPlatformToolset)<'\n-                vcxproj = f.read().replace(b'PlatformToolset>v100<',\n-                                           toolset_repl)\n-                assert toolset_repl in vcxproj, (\n-                   'Upgrading Freetype might break this')\n-                f.seek(0)\n-                f.truncate()\n-                f.write(vcxproj)\n-\n-            cc = get_ccompiler()\n-            cc.initialize()\n-            # On setuptools versions that use \"local\" distutils,\n-            # ``cc.spawn([\"msbuild\", ...])`` no longer manages to locate the\n-            # right executable, even though they are correctly on the PATH,\n-            # because only the env kwarg to Popen() is updated, and not\n-            # os.environ[\"PATH\"]. Instead, use shutil.which to walk the PATH\n-            # and get absolute executable paths.\n-            with TemporaryDirectory() as tmpdir:\n-                dest = Path(tmpdir, \"path\")\n-                cc.spawn([\n-                    sys.executable, \"-c\",\n-                    \"import pathlib, shutil, sys\\n\"\n-                    \"dest = pathlib.Path(sys.argv[1])\\n\"\n-                    \"dest.write_text(shutil.which('msbuild'))\\n\",\n-                    str(dest),\n-                ])\n-                msbuild_path = dest.read_text()\n-            msbuild_platform = (\n-                \"ARM64\" if platform.machine() == \"ARM64\" else\n-                \"x64\" if platform.architecture()[0] == \"64bit\" else\n-                \"Win32\")\n-            # Freetype 2.10.0+ support static builds.\n-            msbuild_config = (\n-                \"Release Static\"\n-                if [*map(int, LOCAL_FREETYPE_VERSION.split(\".\"))] >= [2, 10]\n-                else \"Release\"\n-            )\n-\n-            cc.spawn([msbuild_path, str(sln_path),\n-                      \"/t:Clean;Build\",\n-                      f\"/p:Configuration={msbuild_config};\"\n-                      f\"Platform={msbuild_platform}\"])\n-            # Move to the corresponding Unix build path.\n-            libfreetype.parent.mkdir()\n-            # Be robust against change of FreeType version.\n-            lib_paths = Path(src_path / \"objs\").rglob('freetype*.lib')\n-            # Select FreeType library for required platform\n-            lib_path, = [\n-                p for p in lib_paths\n-                if msbuild_platform in p.resolve().as_uri()\n-            ]\n-            print(f\"Copying {lib_path} to {libfreetype}\")\n-            shutil.copy2(lib_path, libfreetype)\n-\n-\n-class Qhull(SetupPackage):\n-    name = \"qhull\"\n-    _extensions_to_update = []\n-\n-    @classmethod\n-    def add_flags(cls, ext):\n-        if options.get(\"system_qhull\"):\n-            ext.libraries.append(\"qhull_r\")\n-        else:\n-            cls._extensions_to_update.append(ext)\n-\n-    def do_custom_build(self, env):\n-        if options.get('system_qhull'):\n-            return\n-\n-        toplevel = get_and_extract_tarball(\n-            urls=[\"http://www.qhull.org/download/qhull-2020-src-8.0.2.tgz\"],\n-            sha=LOCAL_QHULL_HASH,\n-            dirname=f\"qhull-{LOCAL_QHULL_VERSION}\",\n-        )\n-        shutil.copyfile(toplevel / \"COPYING.txt\", \"LICENSE/LICENSE_QHULL\")\n-\n-        for ext in self._extensions_to_update:\n-            qhull_path = Path(f'build/qhull-{LOCAL_QHULL_VERSION}/src')\n-            ext.include_dirs.insert(0, str(qhull_path))\n-            ext.sources.extend(\n-                map(str, sorted(qhull_path.glob('libqhull_r/*.c'))))\n-            if sysconfig.get_config_var(\"LIBM\") == \"-lm\":\n-                ext.libraries.extend(\"m\")\n-\n-\n-class BackendMacOSX(OptionalPackage):\n-    name = 'macosx'\n-\n-    def check(self):\n-        if sys.platform != 'darwin':\n-            raise Skipped(\"Mac OS-X only\")\n-        return super().check()\n-\n-    def get_extensions(self):\n-        ext = Extension(\n-            'matplotlib.backends._macosx', [\n-                'src/_macosx.m'\n-            ])\n-        ext.extra_compile_args.extend(['-Werror'])\n-        ext.extra_link_args.extend(['-framework', 'Cocoa'])\n-        if platform.python_implementation().lower() == 'pypy':\n-            ext.extra_compile_args.append('-DPYPY=1')\n-        yield ext\n"}